from fastapi import FastAPI, UploadFile, Form, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import subprocess, os, shutil, uuid, json, threading

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://sanskar0104.github.io/code_runner_frontend/"],  # Your GitHub Pages frontend
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def run_aider_with_prompt_detection(cmd, cwd):
    proc = subprocess.Popen(
        cmd,
        cwd=cwd,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1,
        universal_newlines=True
    )

    def monitor_stdout():
        for line in proc.stdout:
            print("[AIDER] →", line.strip())
            try:
                if "Run shell command?" in line:
                    proc.stdin.write("n\n")
                    proc.stdin.flush()
                elif "?" in line and "(Y)es" in line and proc.poll() is None:
                    proc.stdin.write("y\n")
                    proc.stdin.flush()
            except Exception as e:
                print("❌ Failed to respond:", e)

    thread = threading.Thread(target=monitor_stdout)
    thread.start()
    proc.wait()
    thread.join()

    if proc.returncode != 0:
        raise subprocess.CalledProcessError(proc.returncode, cmd)

    return proc

@app.post("/aider-generate/")
async def aider_generate(prompt: str = Form(...), file: UploadFile = None):
    run_id = str(uuid.uuid4())
    aider_dir = f"/tmp/aider_{run_id}"
    run_dir = f"/tmp/run_{run_id}"
    os.makedirs(aider_dir, exist_ok=True)
    os.makedirs(run_dir, exist_ok=True)

    experiment_path = os.path.join(aider_dir, "experiment.py")

    try:
        if file:
            with open(experiment_path, "wb") as f:
                f.write(await file.read())
        else:
            with open(experiment_path, "w") as f:
                f.write("# Empty file generated by Aider\n")

        run_aider_with_prompt_detection(
            ["aider", "experiment.py", "--message", prompt],
            cwd=aider_dir
        )

        shutil.copy2(experiment_path, os.path.join(run_dir, "experiment.py"))

        with open(experiment_path, "r") as f:
            code_result = f.read()
        return JSONResponse({"generated_code": code_result})

    except subprocess.CalledProcessError as e:
        return JSONResponse({"error": str(e)}, status_code=500)
    finally:
        shutil.rmtree(aider_dir)

@app.post("/run-code/")
async def run_code(payload: dict):
    code = payload.get("code", "")
    run_id = str(uuid.uuid4())
    run_dir = f"/tmp/run_{run_id}"
    os.makedirs(run_dir, exist_ok=True)

    script_path = os.path.join(run_dir, "experiment.py")
    with open(script_path, "w") as f:
        f.write(code)

    try:
        result = subprocess.run(["python", script_path], capture_output=True, text=True, timeout=15, cwd=run_dir)

        for f_name in os.listdir(run_dir):
            if f_name.endswith(".json") and f_name != "output.json":
                os.rename(os.path.join(run_dir, f_name), os.path.join(run_dir, "output.json"))

        json_path = os.path.join(run_dir, "output.json")
        if os.path.exists(json_path):
            with open(json_path) as jf:
                return {"result": json.load(jf), "stdout": result.stdout}
        else:
            return {"error": "No JSON file created."}

    except subprocess.TimeoutExpired:
        return {"error": "Script timed out"}
    except Exception as e:
        return {"error": str(e)}
    finally:
        shutil.rmtree(run_dir)

@app.post("/upload-json/")
async def upload_json(file: UploadFile = File(...)):
    run_id = str(uuid.uuid4())
    run_dir = f"/tmp/run_{run_id}"
    os.makedirs(run_dir, exist_ok=True)

    output_path = os.path.join(run_dir, "output.json")
    try:
        with open(output_path, "wb") as f:
            f.write(await file.read())

        with open(output_path, "r") as f:
            return {"result": json.load(f)}
    except Exception as e:
        return {"error": str(e)}
    finally:
        shutil.rmtree(run_dir)
