from fastapi import FastAPI, UploadFile, Form
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import os, shutil, uuid, json
import pexpect

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://sanskar0104.github.io"],  # Replace with your GitHub Pages domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.post("/aider-generate/")
async def aider_generate(prompt: str = Form(...), file: UploadFile = None):
    run_id = str(uuid.uuid4())
    run_dir = f"/tmp/aider_{run_id}"
    os.makedirs(run_dir, exist_ok=True)

    try:
        if file:
            filename = os.path.join(run_dir, file.filename)
            with open(filename, "wb") as f:
                f.write(await file.read())
            target = file.filename
        else:
            target = "experiment.py"
            filepath = os.path.join(run_dir, target)
            with open(filepath, "w") as f:
                f.write("# Empty file generated by Aider\n")

        # Spawn Aider process with pexpect
        child = pexpect.spawn(
            f"aider {target} --message \"{prompt}\"",
            cwd=run_dir,
            encoding='utf-8',
            timeout=180
        )

        while True:
            index = child.expect([
                "Run shell command.*\\[Yes\\]:",
                pexpect.EOF,
                pexpect.TIMEOUT
            ])
            if index == 0:
                child.sendline("n")  # Respond "no" to running shell commands
            elif index == 1:
                break
            elif index == 2:
                return JSONResponse({"error": "Timed out waiting for Aider"}, status_code=500)

        child.wait()

        with open(os.path.join(run_dir, target), "r") as f:
            code = f.read()
        return JSONResponse({"generated_code": code})

    except Exception as e:
        return JSONResponse({"error": str(e)}, status_code=500)
    finally:
        shutil.rmtree(run_dir)

@app.post("/run-code/")
async def run_code(payload: dict):
    code = payload.get("code", "")
    run_id = str(uuid.uuid4())
    run_dir = f"/tmp/run_{run_id}"
    os.makedirs(run_dir, exist_ok=True)

    script_path = os.path.join(run_dir, "experiment.py")
    with open(script_path, "w") as f:
        f.write(code)

    try:
        result = subprocess.run(["python", script_path], capture_output=True, text=True, timeout=15, cwd=run_dir)
        json_file = next((f for f in os.listdir(run_dir) if f.endswith(".json")), None)

        if result.returncode != 0:
            return {"error": "Execution failed", "stderr": result.stderr, "stdout": result.stdout}

        if json_file:
            with open(os.path.join(run_dir, json_file)) as jf:
                return {"result": json.load(jf), "stdout": result.stdout}
        else:
            return {"error": "No JSON file created."}

    except subprocess.TimeoutExpired:
        return {"error": "Script timed out"}
    except Exception as e:
        return {"error": str(e)}
    finally:
        shutil.rmtree(run_dir)
